# -*- coding: utf-8 -*-
"""OOps_practice.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mgMkrOskv9xovaLx0xEFOKDU_hI6Qa_a
"""

class YourClass:
  pass    # an empty class definition

obj = YourClass()    # Creating an instance

#instance variables

class TiClass:
  def increment(self):
    if not hasattr(self, 'instance_var'):
      self.instance_var = 0
    self.instance_var += 1
    return self.instance_var

obj = TiClass()
obj.increment()

#class variables

class Phone:
  class_var = 0

  def increment(self):
    self.class_var += 1
    return self.class_var

obj = Phone()
obj1 = Phone()
print(Phone.class_var)
obj.increment()
print(obj.class_var)
print(obj1.class_var)

#methods in class
#-------A Normal methods

class Phone:
  def set_color(self):
    print("This is coloration of there")

onj = Phone()
onj.set_color()

#class methods
class Mine:
  class_var = 0

  def increment(self):
    Mine.class_var += 1

obj1 = Mine()
obj2 = Mine()

print(Mine.class_var)
obj1.increment()
print(Mine.class_var)
obj2.increment()
print(Mine.class_var)

#static Methods
class Maths:
  @staticmethod
  def is_even(num):
    return num % 2 == 0

  @staticmethod
  def is_prime(num):
    if num < 2:
      return False
    for i in range(2, int(num ** 0.5) + 1):
      if num % i == 0:
        return False
    return True

print(Maths.is_even(2))
print(Maths.is_prime(7))

# __init__ methods
class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

per1 = Person("Nosh", 20)
print(per1.name)
print(per1.age)

# __str__
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name}({self.age})"


person1 = Person("Nosh", 20)
print(person1)
print(str(person1))

# __new__ method
class Person:
  def __new__(cls, *args, **kwargs):
    print("New method called")
    instance = super().__new__(cls)
    return instance

  def __init__(self, name, age):
    self.name = name
    self.age = age

  def __str__(self):
    return f"{self.name}({self.age})"

person1 = Person("Nosh", 20)
print(person1)

#constructors and deconstructors
class Myclass:
  def __init__(self):
    print("Constructor called")

  def __del__(self):
    print("Destructor called")

obj = Myclass()
del obj

#methods with arguments

class MyPhone:
  def my_case(self, arg1, arg2):
    print(f"Arguments: {arg1}, {arg2}")

my_phone = MyPhone()
my_phone.my_case("Samsung", "Galaxy")

#method overloading
class MyClass:
    def my_method(self, arg1, arg2=0):
        print(f"arg1: {arg1}, arg2: {arg2}")

obj = MyClass()
obj.my_method(10)
obj.my_method(10, 20)

class Player:

  def __init__(self, name):
    self._name = name  # Name of the player (using convention for encapsulation)

  def get_name(self):
    return self._name


player1 = Player("Alice")

print(player1.get_name())

#data abstraction
class Employee:
    def __init__(self, name, age, salary):

        self.name = name
        self.age = age
        self.__salary = salary

    def get_salary(self):
        return self.__salary

    def set_salary(self, new_salary):
        if new_salary > 0:
            self.__salary = new_salary
        else:
            print("Invalid salary")

employee = Employee("Johnny", 30, 5090)

print(employee.get_salary())

employee.set_salary(6069)
print(employee.get_salary())

#data hiding
class MyClass:
    def __init__(self):
        self.__hidden_var = 0
    def get_hidden_var(self):
        return self.__hidden_var
    def set_hidden_var(self, value):
        self.__hidden_var = value
obj = MyClass()
obj.set_hidden_var(69)
print(obj.get_hidden_var())