# -*- coding: utf-8 -*-
"""All_datatypes_inf.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/140OdO9p9HM-T83tnxTiJHIGBmt8LvF-s
"""

# lets go with python
print("app hi ho guyzz bus")







if(5>2):
  print("There will be probabily gonna big than 2")
  print("if ulta than got a big")

#python variables
x=6;
x=48;   # it will definately override it------
y = "RAM and DISK"
a = str(5)
j = int(10)
z = float(9)
print(type(a))
print(type(y))
print(type(z))
print(x)

x ,y ,z ="many", "Brow", "honey"
print(x)
print(y)
print(z)

fruit = ['apple', 'banana', 'cherry']
x, y, z,  = fruit
print(x)
print(y)
print(z)

x = "Python "
y = "is "
z = "snake "
print(x + y + z)

def myFun():
  global x
  x = "mohit"
def myGun():
  global y
  y = "Rahul"
myGun()
print("Python is " + y)

x = 10e3
y = 10E4
print(type(x))
print(type(y))

x = 1
y = 2.4
z = 3j
a = float(x)
b = int(y)
c = complex(x)
print(type(a))
print(type(b))
print(type(c))
print(a)
print(b)
print(c)

z = int("3")
print(z)

import random
print(random.randrange(1,100))     #it's for guessing random number between given range by just provide these keywords (random.randrange(range))-------------------

a = "Hello, guyzzzz"
print(a[10])
print(len(a))
#String are array

for x in "jalandhar":
  print(x)

txt = "The best things in life are free!"
print("free" in txt)

txt = "The best things in life are free!"
if "free" in txt:
  print("Yes, 'free' is present.") #it's help to check in the given format or not so we just give the requirment and go for in

txt = "The best things in life are free!"
if "expenxive" not in txt:       # and not for you know alternate way to check
  print("No, 'exception' is NOT present")

#Slicing string
b = "Hello, world";
print(b[2:4])
print(b[:5])
print(b[2:])
print(b[-5:-2])

#modification of string cases
a = "Hello bacche"
print(a.upper())
print(a.lower())
print(a.strip(a)) # remove white spaces
print(a.replace("H", "i"))    #use for replacing the value in string
print(a.split(" "))          #use to split string as given like i split in this one by space

#string concatenation
a = "Hello"
b = "didi"
c =  a+ " " +b
print(c)

age = 36
txt = "My name is John, and I am {}"
print(txt.format(age))
#Use the format() method to insert numbers into strings

#String formating
#in this one we gonna add some info
quantity = 3
item = 345
price = 65.4
myOrder = "I want {} pieces of item{} for {} dollers"
print(myOrder.format(quantity, item, price))

# Escape Character
txt = "We are the so-called \"vikings\" form the north."
print(txt)

#python booleans
print(10>9)
print(10 == 9)
print(10 < 9)

bool("abc")
bool(123)
bool(["apple", "cherry", "banana"])
#here some values are true

#here some valus are false
bool(False)
bool(None)
bool(0)
bool("")
bool(())
bool([])
bool({})

class myClass():
  def ____len____(self):
    return 0
myobj = myClass()
print(bool(myobj))

x = 200
print(isinstance(x, int))

#operators
print(10+5)

#list these are mutable means changable allow duplication
mylist = ["apple", 34, "Banana", "Cherry", "apple"]
print(mylist)
print(len(mylist))

#the list cnstructor
thislist = list(("apple", "banana", "cherry")) # note the double round-brackets
print(thislist)

#python to access list items
thislist = ["apple", 34, "Banana", "Cherry", "apple"]
print(thislist[3])
print(thislist[1:4])
print(thislist[-4:-1])
if "apple" in thislist:
  print("Yup! it's present in this one")

# change item value
thislist = ["apple", 34, "Banana", "Cherry", "apple"]
thislist[3] = "blankare"
print(thislist)

thislist = ["apple", 34, "Banana", "Cherry", "apple"]
thislist[1:3] = ["blackcurrent", "Watermelon"]
thislist[1:3] = ["watemelonn"]
print(thislist)

#insert items in list
thislist = ["Apple" , "banana", "cherry"]
thislist.insert(2, "Watermelonnn")
print(thislist)

#append items in list
thislist = ["Apple" , "banana", "cherry"]
thislist.append("orange")
print(thislist)

#this is how we append Extend list
thislist = ["apple", "banana", "cherry"]
tropical = ["mango", "pineapple", "papaya"]
thislist.extend(tropical)
print(thislist)

#add any iterable
thislist = ["apple", "banana", "cherry"]
thistuple = ("kiwi", "orange")
thislist.extend(thistuple)     #use extend and add items whatever we want
print(thislist)

#remove Specified item
thislist = ["apple", "banana", "cherry"]
thislist.remove("banana")
print(thislist)

#remove a specified index
thislist = ["apple", "banana", "cherry"]
thislist.pop(1)
print(thislist)

thislist = ["apple", "banana", "cherry"]
thislist.clear()
print(thislist)

#loop list
thislist = ["apple", "banana", "cherry"]
for c in thislist:
  print(c)

thislist = ["apple", "banana", "cherry"]
for i in range(len(thislist)):
  print(thislist[i])

#using while loop
thislist = ["apple", "banana", "cherry"]
i = 0
while i < len(thislist):
  print(thislist[i])
  i = i + 1

#list comprehnsion
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = []
for x in fruits:
  if "a" in fruits:
    newlist.append(x)

print(newlist)

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if "a" in x]

print(newlist)

"""newlist = [expression for item in iterable if condition == True]
this is syntex of given format

"""

newlist = [x for x in fruits if x != "apple"]

newlist = [x for x in range(10)]

newlist = [x for x in range(10) if x < 5]

newlist = [x.upper() for x in fruits]

newlist = [x if x != "banana" else "orange" for x in fruits]

#sort list
thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]
thislist.sort()
print(thislist)

thislist = [100, 50, 65, 82, 23]
thislist.sort()
print(thislist)

thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]
thislist.sort(reverse = True)
print(thislist) #for sort descending order

def myFun(n):
  return abs(n - 50)
thislise = [100, 50, 65, 82, 23]
thislise.sort(key = myFun)
print(thislist)

thislist = ["banana", "Orange", "Kiwi", "cherry"]
thislist.sort()
print(thislist)

# if you want a case-insensitive sort function, use str.lower as a key function:
thislist = ["banana", "Orange", "Kiwi", "cherry"]
thislist.sort(key = str.lower)
print(thislist)

thislist = ["apple", "banana", "cherry"]
mylist = thislist.copy()
print(mylist)

thislist = ["apple", "banana", "cherry"]
mylist = list(thislist).  #there is another way to copy write list instead of copy
print(mylist)

#join two list
list1 = ["a", "b", "c"]
list2 = [1,2,3]
list3 = list1 + list2
print(list3)

list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]
for x in list2:
  list1.append(x)

print(list1)

"""list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]
list1.extend(list2)
print(list1)
"""

#python tuples,----------------- they are unchangable and unmutable ------------allow duplications
thistuple = ("apple", "banana", "cherry")
print(thistuple)
print(len(thistuple))
print(type(thistuple))

#access tuple items---------------
thistuple = ("apple", "banana", "cherry")
if "apple" in thistuple:
  print("Yes, 'apple' is in the fruits tuple")

x = ("apple", "banana", "cherry")
y = list(x)
y[1] = "kiwi"
x = tuple(y)
print(x)

#Convert into a list
a = ("apple", "samsumng", "blueberry", "dogyyy")
b = list(a)
b[2] = "like"
x = tuple(b)
print(x)

a = ("apple", "samsumng", "blueberry", "dogyyy")
y = list(thistuple)
y.append("oranges")
thistuple = tuple(y)

#Add tuple to a tuple.
thistuple = ("apple", "banana", "cherry")
y = ("orange",)
thistuple += y
print(thistuple)

"""Tuples are unchangeable, so you cannot remove items from it, but you can use the same workaround as we used for changing and adding tuple items:"""

#del the tuple
thistuple = ("apple", "banana", "cherry")
del thistuple
print(thistuple)
#this will raise an error because the tuple no longer exists

#unpacking of tuple
thistuple = ("apple", "banana", "cherry")
(green, yellow, red) = thistuple
print(green)
print(yellow)
print(red)

fruits = ("apple", "mango", "papaya", "pineapple", "cherry")
(green, *tropic, red) = fruits

print(green)
print(tropic)
print(red)

"""If the number of variables is less than the number of values, you can add an * to the variable name and the values will be assigned to the variable as a list

"""

#loops in tuple
thistuple = ("apple", "banana", "cherry")
for x in thistuple:
  print(x)

thistuple = ("apple", "banana", "cherry")
i = 0
while i<len(thistuple):
  print(thistuple[i])
  i = i + 1

thistuple = ("apple", "banana", "cherry")
mytuple = thistuple * 3
print(mytuple)

#SETS
# unordered -------- Unchangeable--------- Duplicate not allowed
thisset = {"apple", "banana", "cherry", "apple"}
print(thisset)

thisset = {"apple", "banana", "cherry", True, 1, 2}
print(thisset)

#python dictionaries -------changeable---------duplicated not allowed
#first one is key and inner one is value
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict)
print(thisdict["brand"])
print(len(thisdict))

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "colours": ["red", "yellow", "green"],
  "mute":("set", "yellp", "fghjkl")
}
print(type(thisdict))

#the dict() constructor
thisdict = dict(name = "john", age = 36, country = "norway")
print(thisdict)

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "colours": ["red", "yellow", "green"],
  "mute":("set", "yellp", "fghjkl")
}
x = thisdict.keys()    #for keys
print(x)
thisdict["mut"] = "wert"          #this is how could we add the new elements in an dictionari
print(x)

x = thisdict.values() #for values
print(x)
thisdict["year"] = 2003
print(x)

#The items() method will return each item in a dictionary, as tuples in a list.
x = thisdict.items()
print(x)
thisdict["year"] = 3030
print(x)

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
if "model" in thisdict:
  print("yes, 'model' is one of the key on thisdict dictionary")
thisdict.update({"year": 2025})
print(thisdict)

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.pop("model")
print(thisdict)

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
del thisdict["model"]
thisdict.popitem()          #removes the last item form the dictionary
print(thisdict)

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
for x in thisdict:
  print(x)            #---------it shows only keys of dictionary
  print(thisdict[x])         #------------it shows only values of those keys

for x in thisdict.keys():          # only keys
  print(x)

for x in thisdict.values():         #as i say only values
  print(x)

for x,y in thisdict.items():
  print(x, y)            #it will print both keys and values

#how could we copy any dictionary
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = thisdict.copy()
print(mydict)

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = dict(thisdict)
print(mydict)

#Nested dictionaries
child1 = {
    "name" : "Emil",
    "year" : 2004
  }
child2 = {
    "name" : "Tobias",
    "year" : 2007
  }
child3 = {
    "name" : "Linus",
    "year" : 2011
  }

myfamily = {
    "child1" : child1,
    "child2" : child2,
    "child3" : child3
  }
print(myfamily["child2"]["name"])

for x, obj in myfamily.items():
  print(x)
  for y in obj:
    print(y+ ':', obj[y])

#conditional statements means if else

a = 22
b = 343
if b>a:
  print("yeah! boiii")



a = 200
b = 33
if b > a:
  print("b is greater than a")
elif a == b:
  print("a and b are equal")
else:
  print("a is greater than b")

#short hand if
if a>b: print("a is greater than b")

a = 10
b = 10
print("A") if b > a else print("=") if a == b else print("B")

#the values and fuction for and examples in such a way
a = 200
b = 33
c = 500
if a > b and c >a :
  print("Both conditions are true")

a = 200
b = 33
c = 500
if a > b or a > c:
  print("At least one of the conditions is True")

a = 33
b = 200
if not a > b:
  print("a is NOT greater than b")

x = 32
if x > 10:
  print("Above ten,")
  if x > 20:
    print("and also have 20!")
  else:
    print("but not above 20")

a = 33
b = 300
if b > a:
  pass



"""if statements cannot be empty, but if you for some reason have an if statement with no content, put in the pass statement to avoid getting an error."""

#while loop
i = 1
while i < 6:
  print(i)
  i += 1

i = 1
while i < 6:       #it shows us that do this work while given condition
  print(i)              #print the given statement
  if i == 3:           # give another condition loop
    break              #it will stop as according to the given condition
  i += 1          #print in that format

i = 1
while i < 5:
  i += 1
  if i == 3:
    continue      #With the continue statement we can stop the current iteration, and continue with the next:
  print(i)

i = 1
while i < 6:
  print(i)
  i += 1
else:
  print("i is no longer less than 6")

from typing import ForwardRef
#----------------for loop
fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)

for x in "banana":
  print(x)

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break
  print(x)

for a in range(1,10):
  if a == 6:
    break
  print(a)

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    continue
  print(x)

for x in range(2, 30, 3):
  print(x)

for c in range(6):
  print(c)
else:
  print("finally finished!")

for x in range(6):
  if x == 3: break
  print(x)
else:
  print("finally finished!")

adj = ["red", "big", "tasty"]
fruits = ["apple", "banana", "cherry"]
for x in adj:
  for y in fruits:
    print(x, y)

for x in [0, 1, 2]:
  pass

#fuctions--------------------
def my_function():
  print("Hellow from function")

#ARGUMENTS PASSES THROUGH A FUNCTION
def name(Yname):
  print(Yname + " YOur welcome")
name("mohit")
name("rahul")
name("rajjju")

def dage(Age):
  if Age < 18:
    print("virgin")
  else:
    print("bhai......!")
dage(20)
dage(10)

def my_func(fname, lname):
  print(fname + " " + lname)
my_func("Ruhi", "sharma")

#Arbitaru Arguments, *args
def my_fuc(*kids):
  print("The youngest child is " + kids[1])
my_fuc("rahul", "tabi", "mufasa")

"""If you do not know how many arguments that will be passed into your function, add a * before the parameter name in the function definition
This way the function will receive a tuple of arguments, and can access the items accordingly:

You can also send arguments with the key = value syntax.

This way the order of the arguments does not matter
"""

def m_fun(child3, child2, child1):
  print("the youngest child is " + child3)
m_fun(child1 = "rahiul", child2 = "tabi", child3 = "mohut")

#ARBITARY KEYWORDS ARGUMENTS **KWARGS
def my_fun(**kid):
  print("his last name is " + kid["lname"])
my_fun(fname = "Tobias", lname = "Refsnes")

#  --------* for tuple args
# ---------** for dictionaries args

#default parameter values
def my_fuc(country = "India"):
  print("I am from "  + country)

my_fuc("Sweden")
my_fuc("china")
my_fuc()
my_fuc("Switzerland")

def my_function(country = "Norway"):
  print("I am from " + country)

my_function("Sweden")
my_function("India")
my_function()
my_function("Brazil")

#passing a list as an argument
def mu_fun(food):
  for x in food:
    print(x)

fruits = ["apple", "Banana", "cherry"]
mu_fun(fruits)

# the pass Statement
def my_fun():
  pass

def my_function(x, /):
  print(x)

my_function(3)

"""You can specify that a function can have ONLY positional arguments, or ONLY keyword arguments.

To specify that a function can have only positional arguments, add , / after the arguments:
"""

def my_func(*, x):
  print(x)
my_func(x = 34)
#To specify that a function can have only keyword arguments, add *, before the arguments:

def mu(a, b, /, *, c, d):
  print(a + b + c + d)
mu(5,6, c = 7, d =8)

"""Any argument before the / , are positional-only, and any argument after the *, are keyword-only.


"""

#RECURSION
def tri_rec(k):
  if(k > 0):
    result = k + tri_rec(k - 1)
    print(result)
  else:
    result = 0
  return result
print("\n\nRecursion Example Results")
tri_rec(9)

"""***Lambda function***"""

x = lambda a : a + 10
print(x(5))

x = lambda a, b: a * b
print(x(8,5))

x = lambda a, b, c : a+b*c
print(x(4, 5, 8))

"""**The power of lambda is better shown when you use them as an anonymous function inside another function.

Say you have a function definition that takes one argument, and that argument will be multiplied with an unknown number**
"""

def myh(n):
  return lambda a : a*n

mydoubler = myh(2)
print(mydoubler(10))

#make a fuction that always triples the number you send in :
def mufun(n):
  return lambda a : a * n
  mytriple = myfun(3)
  print(mytriple(11))

#best example of lambda function usage
def nano(a):
  return lambda b : b * a
mydoubler = nano(2)
mytripler = nano(3)

print(mydoubler(11))
print(mytripler(22))

#classes
class Myclass:
   x = 5
p1 = Myclass()
print(p1.x)

#The_init_()function
#Use the __init__() function to assign values to object properties, or other operations that are necessary to do when the object is being created:
class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age
p1 = Person("John", 40)
print(p1.name)
print(p1.age)

class nhme:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def __str__(self):         #The string representation of an object WITH the __str__() function:
    return f"{self.name}({self.age})"
p1 = nhme("Mohit", 45)
print(p1)

#object method
#Objects can also contain methods. Methods in objects are functions that belong to the object.
class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def mufun(self):
    print("Hello my name is " +self.name)

p1 = Person("Kallu", 45)
p1.mufun()

#the self parameter
class Person:
  def __init__(mysil, name, age):
    mysil.name = name
    mysil.age = age
  def myfun(abc):
    print("Hello my name is "+ abc.name)
p1 = Person("harsh", 45)

p1.myfun()

"""The self parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class.

It does not have to be named self , you can call it whatever you like, but it has to be the first parameter of any function in the class:
"""

#Python inheritance
#-----------------------CREATE A PARENT CLASS---------------------------
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)
  #Use the Person class to create an object, and then execute the printname method:
x = Person("rahul", "kapadia")
x.printname()
#---------------------------CHILD CLASS--------------------------------------
class Student(Person):
  pass
x = Student("Mike", "olsen")
x.printname()

#Note: The __init__() function is called automatically every time the class is being used to create a new object.
#Note: The child's __init__() function overrides the inheritance of the parent's __init__() function.

#To keep the inheritance of the parent's __init__() function, add a call to the parent's __init__() function:
class Student(Person):
  def __init__(self, fname, lname):
    Person.__init__(self, fname, lname)

class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year
x = Student("Mike", "Olsen", 2019)

#Iterators and Iterable
mytuple = ("apple", "banana", "cherry")
myit = iter(mytuple)

print(next(myit))
print(next(myit))
print(next(myit))

#string are also iterable object, containing a sequence of characters:
mystr = "banana"
iyitr = iter(mystr)
print(next(iyitr))
print(next(iyitr))
print(next(iyitr))
print(next(iyitr))
print(next(iyitr))
print(next(iyitr))